/*
 * AMSocket.c
 *
 *	Created on: 2012-03-28
 *		Author: tom.lih
 */

#define _SOCKET_IMP_
#include "AMSocket.h"
#include "AMSocketHelp.h"
#include <errno.h>
#include <stdlib.h>
#include <sys/select.h>

/*
RETURN VALUE
-1 is returned if an error occurs; otherwise the return value is a descriptor referencing the socket. 
ERRORS
EPROTONOSUPPORT  
  The protocol type or the specified protocol is not supported within this domain.  
EAFNOSUPPORT  
  The implementation does not support the specified address family.  
ENFILE  Not enough kernel memory to allocate a new socket structure.  
EMFILE  Process file table overflow.  
EACCES  Permission to create a socket of the specified type and/or protocol is denied.  
ENOBUFS or ENOMEM  
  Insufficient memory is available. The socket cannot be created until sufficient resources are freed.  
EINVAL  Unknown protocol, or protocol family not available.  
Other errors may be generated by the underlying protocol modules. 
*/
AMInt32 a_socket(AMInt32 fd, AMInt32 type, AMInt32 protocol)
{
    AMInt32 s = socket(fd, type, protocol);
    if(-1 == s)
    {
         AMInt32 errCode = socket_errno;
         switch(errCode)
         {
            AM_SOCKET_CASE(EPROTONOSUPPORT,     AME_SOCKET_PROTONOSUPPORT);
            AM_SOCKET_CASE(EAFNOSUPPORT,        AME_SOCKET_AFNOSUPPORT);
            AM_SOCKET_CASE(ENFILE,              AME_SOCKET_NORESOURCE);
            AM_SOCKET_CASE(EACCES,              AME_SOCKET_EACCES);
            AM_SOCKET_CASE(ENOBUFS,             AME_SOCKET_NORESOURCE);
            AM_SOCKET_CASE(ENOMEM,              AME_SOCKET_NORESOURCE);
            AM_SOCKET_CASE(EINVAL,              AME_SOCKET_PROTONOSUPPORT);
            default:
                return AME_SOCKET_ERROR;
        }
    }

    return  s;
}
/*
RETURN VALUE
The call returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket. 
ERROR HANDLING
Linux accept passes already-pending network errors on the new socket as an error code from accept. This behaviour differs from other BSD socket implementations. For reliable operation the application should detect the network errors defined for the protocol after accept and treat them like EAGAIN by retrying. In case of TCP/IP these are ENETDOWN, EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH. 
ERRORS
accept shall fail if: 

EAGAIN or EWOULDBLOCK  
  The socket is marked non-blocking and no connections are present to be accepted.  
EBADF  The descriptor is invalid.  
ENOTSOCK  
  The descriptor references a file, not a socket.  
EOPNOTSUPP  
  The referenced socket is not of type SOCK_STREAM.  
EINTR  The system call was interrupted by a signal that was caught before a valid connection arrived.  
ECONNABORTED  
  A connection has been aborted.  
EINVAL  Socket is not listening for connections.  
EMFILE  The per-process limit of open file descriptors has been reached.  
ENFILE  The system maximum for file descriptors has been reached.  
accept may fail if:  
EFAULT  The addr parameter is not in a writable part of the user address space.  
ENOBUFS, ENOMEM  
  Not enough free memory. This often means that the memory allocation is limited by the socket buffer limits, not by the system memory.  
EPROTO  Protocol error.  
Linux accept may fail if:  
EPERM  Firewall rules forbid connection.  

In addition, network errors for the new socket and as defined for the protocol may be returned. Various Linux kernels can return other errors such as ENOSR, ESOCKTNOSUPPORT, EPROTONOSUPPORT, ETIMEDOUT. The value ERESTARTSYS may be seen during a trace. 
*/
AMInt32 a_accept(AMInt32 fd, struct AMSockAddr * addr, AMSize_t * len)
{
    AMInt32 ret_code = 0;
    if(NULL == addr || NULL == len)
        return AME_SOCKET_AINVALID;

    ret_code = accept(fd, (struct sockaddr *)addr, len);
    if(-1 == ret_code)
    {
         AMInt32 errCode = socket_errno;
         switch(errCode)
         {
            AM_SOCKET_CASE(EWOULDBLOCK,         AME_SOCKET_WOULDBLOCK);
            AM_SOCKET_CASE(EOPNOTSUPP,          AME_SOCKET_SOCKTNOSUPPORT);
            AM_SOCKET_CASE(EPROTO,              AME_SOCKET_PROTONOSUPPORT);
            AM_SOCKET_CASE(ENOBUFS,             AME_SOCKET_NORESOURCE);
            AM_SOCKET_CASE(ENOMEM,              AME_SOCKET_NORESOURCE);
            default:
                return AME_SOCKET_ERROR;
        }
    }

    return AME_SOCKET_SCUESS;
}
/*
RETURN VALUE
On success, zero is returned. On error, -1 is returned, and errno is set appropriately. 
ERRORS
EBADF  sockfd is not a valid descriptor.  
EINVAL  The socket is already bound to an address. This may change in the future: see linux/unix/sock.c for details.  
EACCES  The address is protected, and the user is not the super-user.  
ENOTSOCK  
  Argument is a descriptor for a file, not a socket.  
The following errors are specific to UNIX domain (AF_UNIX) sockets:  
EINVAL  The addrlen is wrong, or the socket was not in the AF_UNIX family.  
EROFS  The socket inode would reside on a read-only file system.  
EFAULT  my_addr points outside the user¡¯s accessible address space.  
ENAMETOOLONG  
  my_addr is too long.  
ENOENT  The file does not exist.  
ENOMEM  Insufficient kernel memory was available.  
ENOTDIR  
  A component of the path prefix is not a directory.  
EACCES  Search permission is denied on a component of the path prefix.  
ELOOP  Too many symbolic links were encountered in resolving my_addr.  
*/
AMInt32 a_bind(AMInt32 fd, struct AMSockAddr * addr, AMSize_t len)
{
    AMInt32 ret_code = 0;
    if(NULL == addr)
        return AME_SOCKET_ERROR;

   ret_code = bind(fd, (struct sockaddr *)addr, len);
   if(-1 == ret_code)
   {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            AM_SOCKET_CASE(EACCES,              AME_SOCKET_EACCES);
            AM_SOCKET_CASE(ENAMETOOLONG,        AME_SOCKET_AINVALID);
            default:
                return AME_SOCKET_ERROR;
        }
    }

   return AME_SOCKET_SCUESS;
}
/*
RETURN VALUE
If the connection or binding succeeds, zero is returned. On error, -1 is returned, and errno is set appropriately. 
ERRORS
The following are general socket errors only. There may be other domain-specific error codes. 

EBADF  The file descriptor is not a valid index in the descriptor table.  
EFAULT  The socket structure address is outside the user¡¯s address space.  
ENOTSOCK  
  The file descriptor is not associated with a socket.  
EISCONN  
  The socket is already connected.  
ECONNREFUSED  
  No one listening on the remote address.  
ETIMEDOUT  
  Timeout while attempting connection. The server may be too busy to accept new connections. Note that for IP sockets the timeout may be very long when syncookies are enabled on the server.  
ENETUNREACH  
  Network is unreachable.  
EADDRINUSE  
  Local address is already in use.  
EINPROGRESS  
  The socket is non-blocking and the connection cannot be completed immediately. It is possible to select(2) or poll(2) for completion by selecting the socket for writing. After select indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure).  
EALREADY  
  The socket is non-blocking and a previous connection attempt has not yet been completed.  
EADDRNOTAVAIL  
  Non-existent interface was requested or the requested address was not local.  
EAFNOSUPPORT  
  The passed address didn¡¯t have the correct address family in its sa_family field.  
EACCES, EPERM  
  The user tried to connect to a broadcast address without having the socket broadcast flag enabled or the connection request failed because of a local firewall rule.  
*/
AMInt32 a_connect(AMInt32 fd, struct AMSockAddr *addr, AMSize_t len)
{
    AMInt32 ret_code = 0;
    if(NULL == addr)
        return AME_SOCKET_ERROR;

    ret_code = connect(fd, (struct sockaddr *)addr, len);
    if(ret_code == -1)
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            AM_SOCKET_CASE(EADDRINUSE,           AME_SOCKET_ADDRINUSE);
            AM_SOCKET_CASE(EAFNOSUPPORT,         AME_SOCKET_AINVALID);
            AM_SOCKET_CASE(ETIMEDOUT,            AME_SOCKET_TIMEDOUT);
            AM_SOCKET_CASE(EACCES,               AME_SOCKET_EACCES);
            AM_SOCKET_CASE(EISCONN,              AME_SOCKET_ISCONN);
            AM_SOCKET_CASE(ENETUNREACH,          AME_SOCKET_NETUNREACH);
            AM_SOCKET_CASE(ECONNREFUSED,         AME_SCOKET_CONNREFUSED);
            AM_SOCKET_CASE(EINPROGRESS,          AME_SOCKET_WOULDBLOCK);
            AM_SOCKET_CASE(EALREADY,             AME_SOCKET_WOULDBLOCK);
            default:
                return AME_SOCKET_ERROR;
        }
    }
    return AME_SOCKET_SCUESS;
}

AMInt32 a_asyn_connect(AMInt32 fd, struct AMSockAddr *addr, 
        AMSize_t len, struct AMTimeval *timeout)
{
    AMUInt32 flag = 1;
    if(NULL == timeout)
        return a_connect(fd, addr, len);
    else
    {
        fd_set wset;
        AMInt32 connect_err;
        //ÉèÖÃconnectÎª·Ç×èÈû,
	    if(ioctl(fd, FIONBIO, &flag) == -1)
            return AME_SOCKET_ERROR;
        if((connect_err = connect(fd, (struct sockaddr*)&addr, sizeof(struct AMSockAddr))) ==  -1)
        {
            int err = socket_errno;
            if(err == NET_EWOULDBLOCK)	
            {
                int select_err; 
                FD_ZERO(&wset);
                FD_SET(fd, &wset); 

                if((select_err = select(fd + 1, &wset, &wset, NULL, (AMPVoid)timeout)) == 0 )		//the count.
                {
                    goto AM_CONNECT_FAILED;
                }

                if(FD_ISSET(fd, &wset))		//connect successful.
                {
                    goto AM_CONNECT_SCUESS;
                }
            }
            else if(connect_err == 0)
            {
                goto AM_CONNECT_SCUESS;
            }
        }
        
    }
AM_CONNECT_FAILED:
    {
        AMInt32 errCode = socket_errno;
        flag = 0;
        ioctl(fd, FIONBIO, &flag);
        switch(errCode)
        {
            AM_SOCKET_CASE(EINVAL ,           AME_SOCKET_AINVALID);
            default:
                return AME_SOCKET_ERROR;
        }
    }

AM_CONNECT_SCUESS:
    flag = 0;
    ioctl(fd, FIONBIO, &flag);
    return AME_SOCKET_SCUESS;
}
/*
RETURN VALUE
On success, zero is returned. On error, -1 is returned, and errno is set appropriately. 
ERRORS
EADDRINUSE  
  Another socket is already listening on the same port.  
EBADF  The argument s is not a valid descriptor.  
ENOTSOCK  
  The argument s is not a socket.  
EOPNOTSUPP  
  The socket is not of a type that supports the listen operation.  
*/
AMInt32 a_listen(AMInt32 fd, AMInt32 backlog)
{
    AMInt32 err_code = listen(fd, backlog);
    if(err_code == -1)
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            AM_SOCKET_CASE(EADDRINUSE,           AME_SOCKET_ADDRINUSE);
            AM_SOCKET_CASE(EOPNOTSUPP,           AME_SOCKET_SOCKTNOSUPPORT);
            default:
                return AME_SOCKET_ERROR;
        }
    }
    return AME_SOCKET_SCUESS;
}
/*
RETURN VALUE
These calls return the number of bytes received, or -1 if an error occurred. The return value will be 0 when the peer has performed an orderly shutdown. 
ERRORS
These are some standard errors generated by the socket layer. Additional errors may be generated and returned from the underlying protocol modules; see their manual pages. 

EBADF  The argument s is an invalid descriptor.  
ECONNREFUSED  
  A remote host refused to allow the network connection (typically because it is not running the requested service).  
ENOTCONN  
  The socket is associated with a connection-oriented protocol and has not been connected (see connect(2) and accept(2)).  
ENOTSOCK  
  The argument s does not refer to a socket.  
EAGAIN  The socket is marked non-blocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  
EINTR  The receive was interrupted by delivery of a signal before any data were available.  
EFAULT  The receive buffer pointer(s) point outside the process¡¯s address space.  
EINVAL  Invalid argument passed.  
ENOMEM  Could not allocate memory for recvmsg.  
*/
AMInt32 a_recv(AMInt32 fd, AMChar * buffer, AMSize_t len, AMInt32 flags)
{
    AMInt32 ret_code = 0;
    if(NULL == buffer)
        return AME_SOCKET_ERROR;


    ret_code = recv(fd, buffer, len, flags);
    if(ret_code > 0)
        return ret_code;
    else if(ret_code == 0)
        return AME_SOCKET_SHUTDOWN;
    else
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            AM_SOCKET_CASE(EBADF,               AME_SOCKET_AINVALID);
            AM_SOCKET_CASE(EAGAIN,              AME_SOCKET_TIMEDOUT);
            AM_SOCKET_CASE(ENOTCONN,            AME_SOCKET_NOTCONN);
            default:
                return AME_SOCKET_ERROR;
        }
    }
}
/*
RETURN VALUE
The calls return the number of characters sent, or -1 if an error occurred. 
ERRORS
These are some standard errors generated by the socket layer. Additional errors may be generated and returned from the underlying protocol modules; see their respective manual pages. 

EAGAIN or EWOULDBLOCK  
  The socket is marked non-blocking and the requested operation would block.  
EBADF  An invalid descriptor was specified.  
ECONNRESET  
  Connection reset by peer.  
EDESTADDRREQ  
  The socket is not connection-mode, and no peer address is set.  
EFAULT  An invalid user space address was specified for a parameter.  
EINTR  A signal occurred before any data was transmitted.  
EINVAL  Invalid argument passed.  
EISCONN  
  The connection-mode socket was connected already but a recipient was specified. (Now either this error is returned, or the recipient specification is ignored.)  
EMSGSIZE  
  The socket type requires that message be sent atomically, and the size of the message to be sent made this impossible.  
ENOBUFS  
  The output queue for a network interface was full. This generally indicates that the interface has stopped sending, but may be caused by transient congestion. (Normally, this does not occur in Linux. Packets are just silently dropped when a device queue overflows.)  
ENOMEM  No memory available.  
ENOTCONN  
  The socket is not connected, and no target has been given.  
ENOTSOCK  
  The argument s is not a socket.  
EOPNOTSUPP  
  Some bit in the flags argument is inappropriate for the socket type.  
EPIPE  The local end has been shut down on a connection oriented socket. In this case the process will also receive a SIGPIPE unless MSG_NOSIGNAL is set.  
*/

AMInt32 a_send(AMInt32 fd, const AMChar* buffer, AMSize_t len, AMInt32 flags)
{
    AMInt32 ret_code = 0;
    if(NULL == buffer)
        return AME_SOCKET_ERROR;

    ret_code = send(fd, buffer, len, flags);
    if(ret_code != -1)
        return  ret_code;
    else
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            AM_SOCKET_CASE(EPIPE,                   AME_SOCKET_SHUTDOWN);
            AM_SOCKET_CASE(ECONNRESET,              AME_SOCKET_NETRESET);
            AM_SOCKET_CASE(ENOTCONN,                AME_SOCKET_NOTCONN);
            AM_SOCKET_CASE(EWOULDBLOCK,             AME_SOCKET_WOULDBLOCK);
            default:
                return AME_SOCKET_ERROR;
        }
    }
}
/*
RETURN VALUE
On success, zero is returned. On error, -1 is returned, and errno is set appropriately. 
ERRORS
EBADF  s is not a valid descriptor.  
ENOTSOCK  
  s is a file, not a socket.  
ENOTCONN  
  The specified socket is not connected.  
*/
AMInt32 a_shutdown(AMInt32 fd, AMInt32 flags)
{
    if(shutdown(fd, flags) == 0)
        return AME_SOCKET_SCUESS;
    else 
        return AME_SOCKET_ERROR;
}
/*
RETURN VALUE
close returns zero on success, or -1 if an error occurred. 
ERRORS
EBADF  fd isn¡¯t a valid open file descriptor.  
EINTR  The close() call was interrupted by a signal.  
EIO  An I/O error occurred.  
*/
AMInt32 a_close(AMInt32 fd)
{
    if(close(fd) == 0)
        return AME_SOCKET_SCUESS;
    else 
        return AME_SOCKET_ERROR;
}

AMUInt32 a_inet_addr(const AMChar* ipstr)
{
    return inet_addr(ipstr);
}

AMUInt16 a_htons(AMUInt16 hs)
{
/*
#if _BYTE_ORDER == _BIG_ENDIAN
	return hs;
#else
	AMChar ret_hs[2];
	ret_hs[0] = *(((AMChar*)&hs) + 1);
	ret_hs[1] = *(((AMChar*)&hs) + 0);
	return *(AMUInt16*)ret_hs;
#endif
*/
	return htons(hs);
}

AMUInt32  a_htonl(AMUInt32 hl)
{
/*
#if _BYTE_ORDER == _BIG_ENDIAN
	return hl;
#else
	unsigned AMChar ret_hl[4];
	ret_hl[0] = *(((unsigned AMChar*)&hl) + 3);
	ret_hl[1] = *(((unsigned AMChar*)&hl) + 2);
	ret_hl[2] = *(((unsigned AMChar*)&hl) + 1);
	ret_hl[3] = *(((unsigned AMChar*)&hl) + 0);
	return *(AMUInt32*)ret_hl;
#endif
*/
	return htonl(hl);
}

AMInt32 a_gethostbyname(struct AMHostent** host,const AMChar* name)
{
    AMInt32 ret_code = 0;
    if(NULL == name)
        return AME_SOCKET_ERROR;

    *host = (struct AMHostent*)gethostbyname(name);
    if(*host == NULL)
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
            /*AM_SOCKET_CASE(WSAHOST_NOT_FOUND ,     AME_SOCKET_HOST_NOT_FOUND);
            AM_SOCKET_CASE(WSATRY_AGAIN,          AME_SOCKET_TRY_AGAIN);
            AM_SOCKET_CASE(WSANO_RECOVERY,         AME_SOCKET_NO_RECOVERY);
            AM_SOCKET_CASE(WSANO_DATA,              AME_SOCKET_NO_DATA);*/
        default:
            return AME_SOCKET_ERROR;
        }
    }
	
    return AME_SOCKET_SCUESS;
}

#ifdef AM_SOCKET_SUPPORT_UDP
AMInt32 a_recvfrom(AMInt32 fd, AMChar * buffer, AMSize_t len, AMInt32 flags, 
    struct AMSockAddr * from, AMSize_t * fromlen)
{
    return AME_SOCKET_ERROR;
}
AMInt32 a_sendto(AMInt32 fd, const AMChar * buffer, AMSize_t len, AMInt32 flags, 
    struct AMSockAddr * to, AMSize_t tolen)
{
    return AME_SOCKET_ERROR;
}
#endif

#ifdef AM_SOCKET_SUPPORT_OPTION
AMInt32 a_getsockopt(AMInt32 fd, AMInt32 level, AMInt32 optname, AMPVoid optval,  AMSize_t* optlen)
{
     return AME_SOCKET_ERROR;
}
AMInt32 a_setsockopt(AMInt32 fd, AMInt32 level, AMInt32 optname, AMPVoid optval,  AMSize_t optlen)
{
    return AME_SOCKET_ERROR;
}
#endif

#ifdef AM_SOCKET_SUPPORT_IOCTL
AMInt32 a_ioctl(AMInt32 fd, AMInt32 request, ...)
{
    return AME_SOCKET_ERROR;
}
AMInt32 a_select(AMInt32 n, AMFdSet *readfds, AMFdSet *writefds, AMFdSet *exceptfds, struct AMTimeval *timeout)
{
    AMInt32 ret_code = 0;
    ret_code = select(n, readfds, writefds, exceptfds, (struct timeval*)timeout);
    if(ret_code != -1)
        return  ret_code;
    else
    {
        AMInt32 errCode = socket_errno;
        switch(errCode)
        {
        default:
            return AME_SOCKET_ERROR;
        }
    }
    return AME_SOCKET_SCUESS;
}
#endif
